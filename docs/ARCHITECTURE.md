# kvlite 架构设计文档

本文档面向**开发者与贡献者**，描述 kvlite 的内部实现、数据格式与演进路线。

> 用户文档请参考 [DESIGN.md](./DESIGN.md)

---

## 1. 设计目标

### 1.1 核心目标

- **崩溃安全** - 崩溃/断电后可恢复到一致状态
- **嵌入优先** - 作为 Rust crate 嵌入使用，零依赖服务
- **简单可维护** - 优先正确性与代码可读性，再考虑性能优化
- **可演进架构** - 可逐步升级到 LSM、Compaction 等高级特性

### 1.2 明确不支持的特性

- 分布式与网络协议
- 多进程并发写入（v0.x）
- 事务与 MVCC（v0.x）

---## 2. 架构总览 (v0.1)

v0.1 采用最小可靠实现，包含三个核心组件：

- **WAL 文件** - 追加写入操作日志
- **内存索引** - HashMap 快速定位 key 对应的 value 位置
- **崩溃恢复** - 启动时重放 WAL 重建索引

### 2.1 写入流程

1. 编码 record（包含 key、value、校验和）
2. 追加写入 WAL 文件
3. 执行 flush（可选 fsync）
4. 更新内存索引

### 2.2 读取流程

1. 在内存索引中查找 key
2. 根据 offset/len 从 WAL 文件随机读取 value

---

## 3. 模块结构

推荐的代码组织方式：

```
src/
  lib.rs        # 对外导出接口
  db.rs         # Db 主 API 实现
  wal.rs        # WAL 文件读写操作
  codec.rs      # 记录编解码与校验
  error.rs      # 错误类型定义
  stats.rs      # 统计信息 (v0.2+)
```

### 模块职责划分

| 模块       | 职责                                       |
| ---------- | ------------------------------------------ |
| `db.rs`    | 实现 Db 对外 API，组合 WAL + 索引          |
| `wal.rs`   | 文件操作、追加写、随机读、replay、truncate |
| `codec.rs` | record 二进制格式编解码与 CRC 校验         |
| `error.rs` | 统一的错误类型定义                         |

---

## 4. 数据模型

### 4.1 键值类型

- **Key**: `Vec<u8>` - 任意字节序列
- **Value**: `Vec<u8>` - 任意字节序列

### 4.2 内存索引

```rust
HashMap<Vec<u8>, ValuePos>

struct ValuePos {
    offset: u64,  // value 在 WAL 文件中的偏移量
    len: u32,     // value 的字节长度
}
```

**操作语义：**

- `PUT(k, v)` → `index[k] = position(v)`
- `DELETE(k)` → `index.remove(k)`

---

## 5. WAL 记录格式

### 5.1 Record 结构 (v0.1)

每条记录的二进制布局：

```
+--------+--------+------+----------+----------+-----+-------+--------+
| magic  | version| kind | key_len  | val_len  | key | value | crc32  |
+--------+--------+------+----------+----------+-----+-------+--------+
  4 bytes  1 byte  1 byte  4 bytes    4 bytes   var   var    4 bytes
```

**字段说明：**

| 字段      | 大小    | 说明                                |
| --------- | ------- | ----------------------------------- |
| `magic`   | 4 bytes | 固定值 `MKV1`，用于识别文件格式     |
| `version` | 1 byte  | 格式版本号，当前为 `1`              |
| `kind`    | 1 byte  | 操作类型：`1` = PUT，`2` = DELETE   |
| `key_len` | 4 bytes | key 长度（little-endian u32）       |
| `val_len` | 4 bytes | value 长度（little-endian u32）     |
| `key`     | 变长    | 键的字节序列                        |
| `value`   | 变长    | 值的字节序列                        |
| `crc32`   | 4 bytes | 对 `version..value` 的 CRC32 校验和 |

### 5.2 CRC32 校验的必要性

- **检测数据损坏** - 半写入、bit flip、文件截断等
- **避免静默错误** - 明确识别损坏记录
- **恢复策略** - 只保留最后一个完整有效记录之前的数据

---

## 6. 崩溃恢复机制

### 6.1 WAL Replay 流程

启动时执行以下步骤：

1. **顺序读取 WAL** - 从文件头开始扫描
2. **解码记录** - 验证 magic、version、CRC32
3. **应用记录** - 更新内存索引
4. **处理损坏** - 遇到以下情况时：
   - EOF 且记录不完整
   - CRC 校验失败
   - magic/version 无效

   → 认为 WAL 尾部损坏，截断到最后一条完整记录

### 6.2 截断策略

**推荐策略 (v0.1)：**

- 截断损坏部分并返回 `Ok`
- 允许用户继续使用 DB，不因尾部损坏导致完全不可用
- 在日志/统计中记录截断事件

**安全保证：**

- 不丢失完整写入的数据
- 损坏部分是未完成的写入（可安全丢弃）

---

## 7. 持久化语义

### 7.1 同步选项 `Options.sync_on_write`

**`true` (默认)**

- 每次写入后执行 `flush() + fsync()`
- `put/delete` 返回 `Ok` 表示数据已持久化到磁盘
- 崩溃后不会丢失已确认的写入

**`false`**

- 仅执行 `flush()`，不调用 `fsync()`
- 性能更好，但崩溃时可能丢失最后一小段写入
- 适用于对性能要求高、可容忍少量数据丢失的场景

---

## 8. Compaction 设计 (v0.2 计划)

### 8.1 问题

WAL-only 模式下，文件会无限增长：

- 删除操作不释放空间
- 覆盖写入会保留旧值
- 长期运行导致磁盘占用过大

### 8.2 方案

提供 `Db::compact()` 方法：

```
1. 创建新 WAL 文件 `wal.log.new`
2. 遍历内存索引中的所有 key
3. 将当前有效值写入新 WAL
4. 原子替换：rename `wal.log.new` → `wal.log`
5. 重建或更新内存索引中的 offset
```

### 8.3 保证

- **原子性** - 依赖文件系统的 rename 原子语义
- **崩溃恢复** - 通过临时文件命名约定确保 compact 过程可恢复

---

## 9. 未来演进：LSM 架构 (v0.3+)

### 9.1 问题

随着数据量增长，WAL-only 模式的读放大严重：

- 每次读取都需要随机 I/O
- 缺乏数据压缩与索引优化

### 9.2 v0.3 计划：引入 LSM 基础结构

**核心组件：**

- **MemTable** - `BTreeMap`，内存中有序表
- **SSTable** - 磁盘上有序只读文件
- **Flush 机制** - MemTable 满时持久化为 SSTable
- **读取路径** - MemTable → SSTable（从新到旧）

### 9.3 v0.4 计划：Compaction

- 合并多个 SSTable，消除重复与 tombstone
- 减少文件数量，提升读性能

---

## 10. 测试策略

### 10.1 单元测试 (v0.1)

**基本功能：**

- `put/get` 基本操作
- 覆盖写入（last-write-wins）
- 删除后返回 `None`
- 重启后数据持久化

**崩溃恢复：**

- WAL 尾部截断恢复
- CRC 校验失败恢复

### 10.2 属性测试 (可选)

- 随机操作序列（put/get/delete）
- 与参考模型（HashMap）进行等价性验证

### 10.3 基准测试 (v0.2+)

- 顺序写入性能
- 随机读取性能（命中/未命中）
- Compaction 成本分析

---

## 11. 已知限制 (v0.1)

| 限制           | 说明                           |
| -------------- | ------------------------------ |
| **单进程独占** | 无文件锁，不支持多进程同时打开 |
| **无范围查询** | 不支持 range scan 或迭代器     |
| **无事务支持** | 不支持跨操作的原子性与隔离性   |
| **单文件结构** | 仅有 `wal.log` 一个文件        |

---

## 12. 版本规划

**版本语义约定：**

| 版本     | 说明                                    |
| -------- | --------------------------------------- |
| **v0.x** | API 可能变化，实验性功能                |
| **v1.0** | 稳定 API + 完整文档 + 可靠的 Compaction |

---

## 附录

### 相关文档

- [DESIGN.md](./DESIGN.md) - 用户使用指南

### 参考资料

- [Bitcask 论文](https://riak.com/assets/bitcask-intro.pdf)
- [LSM-Tree 架构](https://en.wikipedia.org/wiki/Log-structured_merge-tree)
